title: CLR介绍
category: CLR
date: 2015-03-07 21:15:17
---

这篇文章实际上是来自[intro-to-clr](https://github.com/dotnet/coreclr/blob/master/Documentation/intro-to-clr.md)的翻译，作者是Vance Morrison，.Net的性能架构师（Performance Architect）。据他在Channel9的[CRL through the year](http://channel9.msdn.com/Shows/Going+Deep/Vance-Morrison-CLR-Through-the-Years)视频中称，他是.net组从组建到现在（09年）还留下来的五个人之一，可见还是真心牛逼的。至于我翻译这边文章的目的，也无特殊原因，只是最近[.Net CoreCLR](https://github.com/dotnet/coreclr)即将发布了，我感觉应该学习学习。然后再声明一下，我的翻译可能不是特别精确，我只是按照我的理解然后以顺口的语言翻译出来而已，哪里觉得不准确的还望莫要见怪:)  

正文
=================

什么是Common Language Runtime(CRL)？简单的来说就是：
> CLR是一个被设计用来支持多种编程语言及其互操作的大而全的高层虚拟机  

虽然上面一句话的总结本身不是十分具有启发性，但是还是十分有用的。因为它是我们谈到CLR这种复杂而庞大的软件，并试图以一种容易理解的方式总结其特点的时候所要走的第一步。它给了我们一个很好的关于.net运行时的蓝图，从这里我们可以了解到.net运行时的目的和宗旨。在了解了上面这种高层的定义之后，再深入了解各个子模块的时候就会容易许多，因为这会避免我们迷失在细节之中。  

CLR：一个（罕见的）完整的编程平台
=========
每个程序都有数目令人惊讶的环境依赖。最明显的是，每个程序都是由某种特定的编程语言编写而成的，但是这仅仅是程序员编写程序的第一步而已。所有有趣的程序都需要一些可以帮助他们和计算机中其他资源（例如用户输入，磁盘文件，网络通信等）交互的运行时库。程序还需要被编译成某种原始硬件可以执行的形式。一个程序的依赖是如此多且相互依存，这不得不迫使语言设计者们把一些标准推迟到其他的标准中来指定他们。例如，C++语言并没有指定c++程序的文件格式，我们所看到的是每个C++编译器都被绑定到了一个特定的硬件平台（例如，x86）和一个操作系统（例如，Windows，Linux，或者Mac OS）上，每种不同的绑定都限制了程序的文件格式和加载方式。因此，我们通常不会听到做了一个“C++执行程序”的说法，而是一个“Windows x86执行程序”或者一个"Mac OS执行程序"。  

利用现有的硬件和操作系统的标准通常是一件好事，但这样做的缺点是会将规范绑定到已经存在的抽象的标准中....................

CRL通过定义一个[非常详细的规范](http://www.ecma-international.org/publications/standards/Ecma-335.htm)（通过ECMA标准化）来解决这些问题，这个规范当中包含了所有的关于程序生命周期的细节，从构造到绑定，从部署到执行等等。其中就包括了如下的规范：  
* 一个具有垃圾回收的虚拟机，且这个虚拟机有着自己的用于指定程序执行的原始操作的指令集（称为Common Intermediate Language）。这就意味着CLR不需要依赖于特定的CPU类型。
* 